<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=theme-color content="dark"><title>Functional Programming 101 - With Clojure | Daniel Martins</title><link rel=stylesheet href=/sass/main.min.4e90cee935c47394b47f9cb7ffe8e3ffab18b88d82fea203918cc3f92eec5eb2.css></head><body class=dark><nav class=navbar><div class=container><div class=flex><div><a class=brand href=/><span class=emoji>üë®‚Äçüíª</span>
Daniel Martins</a></div><div class=flex><a href=/>Blog</a>
<a href=/my-setup/>My Setup</a>
<a href=/about/>About</a>
<button id=dark-mode-button></button></div></div></div></nav><main><div class=container><article><header class=article-header><div class=thumb><div><h1>Functional Programming 101 - With Clojure</h1><div class=post-meta><div>By Daniel Martins on <time>January 26, 2014</time></div><div class=tags><a href=/tags/clojure/>clojure</a>
<a href=/tags/programming/>programming</a>
<a href=/tags/challenge/>challenge</a></div></div></div></div></header></article><div class=article-post><p>Here goes a simple yet interesting programming problem originally proposed by
<a href=http://www.iit.edu/csl/cs/faculty/beckman_mattox.shtml>Mattox Beckman</a>. After
seeing <a href=http://blog.gja.in/2014/01/functional-programming-101-with-haskell.html>Tejas Dinkar</a>&rsquo;s
take on this problem using <a href=http://haskell.org>Haskell</a>, I decided to give it
a go with <a href=http://clojure.org>Clojure</a>.</p><blockquote><p>You are Hercules, about to fight the dreaded Hydra. The Hydra has 9 heads.
When a head is chopped off, it spawns 8 more heads. When one of these 8 heads
is cut off, each one spawns out 7 more heads. Chopping one of these spawns 6
more heads, and so on until the weakest head of the hydra will not spawn out
any more heads.</p><p>Our job is to figure out how many chops Hercules needs to make in order to
kill all heads of the Hydra. And no, it&rsquo;s not <em>n!</em>.</p></blockquote><p>We can start by defining a function that returns a <code>n</code>-headed Hydra.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=kd>defn </span><span class=nv>new-hydra</span>
  <span class=s>&#34;Returns a Hydra with n heads.&#34;</span>
  <span class=p>[</span><span class=nv>n</span><span class=p>]</span>
  <span class=p>(</span><span class=nb>repeat </span><span class=nv>n</span> <span class=nv>n</span><span class=p>))</span>

<span class=p>(</span><span class=nf>new-hydra</span> <span class=mi>3</span><span class=p>)</span>
<span class=c1>;; =&gt; (3 3 3)</span>
</code></pre></td></tr></table></div></div><p>To make it easy to compare both solutions, the data structure I&rsquo;m using here
is the same one used by Dinkar: a list. In this list, each number represents
a living head and its level of strength.</p><p>Now, according to the problem description, when Hercules chops off a level 3
head, the Hydra grows two level 2 heads.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>chop-head</span> <span class=p>(</span><span class=nf>new-hydra</span> <span class=mi>3</span><span class=p>))</span>
<span class=c1>;; =&gt; (2 2 3 3)</span>
</code></pre></td></tr></table></div></div><p>Here&rsquo;s one possible implementation for such a function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=kd>defn </span><span class=nv>chop-head</span>
  <span class=s>&#34;Returns a new Hydra after chop off its first head.&#34;</span>
  <span class=p>[</span><span class=nv>hydra</span><span class=p>]</span>
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>head</span> <span class=p>(</span><span class=nb>first </span><span class=nv>hydra</span><span class=p>)]</span>
    <span class=p>(</span><span class=nb>into </span><span class=p>(</span><span class=nb>rest </span><span class=nv>hydra</span><span class=p>)</span>
          <span class=p>(</span><span class=nf>new-hydra</span> <span class=p>(</span><span class=nb>dec </span><span class=nv>head</span><span class=p>)))))</span>
</code></pre></td></tr></table></div></div><p>This code should make sense even if you are not familiar with Clojure.</p><blockquote><p>What happens if Hercules tries to cut off the head of a headless Hydra?</p></blockquote><p>Most functional programming languages I know are laid on top of a strong principle
called the <a href=http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%25_sec_2.2>closure property</a>.</p><blockquote><p>In general, an operation for combining data objects satisfies the closure
property if the results of combining things with that operation can
themselves be combined using the same operation. Closure is the key to power
in any means of combination because it permits us to create hierarchical
structures &ndash; structures made up of parts, which themselves are made up of
parts, and so on.</p><p>&ndash; Gerald Jay Sussman, Hal Abelson</p></blockquote><p>To illustrate this concept with code, let&rsquo;s consider Clojure&rsquo;s <code>cons</code> function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>cons </span><span class=mi>1</span> <span class=p>(</span><span class=nb>cons </span><span class=mi>2</span> <span class=o>&#39;</span><span class=p>()))</span>
<span class=c1>;; =&gt; (1 2)</span>

<span class=p>(</span><span class=nb>cons </span><span class=mi>1</span> <span class=p>(</span><span class=nb>cons </span><span class=mi>2</span> <span class=p>(</span><span class=nb>cons </span><span class=mi>3</span> <span class=nv>nil</span><span class=p>)))</span>
<span class=c1>;; =&gt; (1 2 3)</span>
</code></pre></td></tr></table></div></div><p>That means <code>cons</code> follows the closure principle. But what about our <code>chop-head</code>
function? Does the principle hold?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>chop-head</span> <span class=p>(</span><span class=nf>chop-head</span> <span class=p>(</span><span class=nf>chop-head</span> <span class=o>&#39;</span><span class=p>(</span><span class=mi>2</span><span class=p>))))</span>
<span class=c1>;; =&gt; NullPointerException</span>
</code></pre></td></tr></table></div></div><p>Apparently not. To fix that, we need to make sure <code>dec</code> is not called with
<code>nil</code>, since it&rsquo;s not possible to decrement a null value.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=kd>defn </span><span class=nv>chop-head</span>
  <span class=s>&#34;Returns a new Hydra after chop off its first head.&#34;</span>
  <span class=p>[</span><span class=nv>hydra</span><span class=p>]</span>
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>head</span> <span class=p>(</span><span class=nb>first </span><span class=nv>hydra</span><span class=p>)]</span>
    <span class=p>(</span><span class=nb>into </span><span class=p>(</span><span class=nb>rest </span><span class=nv>hydra</span><span class=p>)</span>
          <span class=p>(</span><span class=nf>new-hydra</span> <span class=p>(</span><span class=nb>dec </span><span class=p>(</span><span class=nb>or </span><span class=nv>head</span> <span class=mi>1</span><span class=p>))))))</span>
</code></pre></td></tr></table></div></div><p>What about now?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>chop-head</span> <span class=p>(</span><span class=nf>chop-head</span> <span class=p>(</span><span class=nf>chop-head</span> <span class=o>&#39;</span><span class=p>(</span><span class=mi>2</span><span class=p>))))</span>
<span class=c1>;; =&gt; ()</span>
</code></pre></td></tr></table></div></div><h2 id=killing-the-hydra>Killing The Hydra</h2><p>In order for Hecules to kill the Hydra, he needs to repeatedly chop off Hydra&rsquo;s
heads while it still has them.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=kd>defn </span><span class=nv>chop-until-dead</span>
  <span class=s>&#34;Repeatedly chops Hydra&#39;s heads until no head is left.&#34;</span>
  <span class=p>[</span><span class=nv>hydra</span><span class=p>]</span>
  <span class=p>(</span><span class=nb>take-while </span><span class=o>#</span><span class=p>(</span><span class=nb>not </span><span class=p>(</span><span class=nf>empty?</span> <span class=nv>%</span><span class=p>))</span>
              <span class=p>(</span><span class=nb>iterate </span><span class=o>#</span><span class=p>(</span><span class=nf>chop-head</span> <span class=nv>%</span><span class=p>)</span> <span class=nv>hydra</span><span class=p>)))</span>
</code></pre></td></tr></table></div></div><p>The <code>(iterate f x)</code> function returns a lazy (infinite) sequence of <code>x</code>, <code>(f x)</code>,
<code>(f (f x))</code>, etc, given that <code>f</code> is a function free of side-effects.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>take </span><span class=mi>3</span> <span class=p>(</span><span class=nb>iterate inc </span><span class=mi>0</span><span class=p>))</span>
<span class=c1>;; =&gt; (0 1 2)</span>
</code></pre></td></tr></table></div></div><p>Since <code>chop-head</code> respects the closure principle by always returning a list,
we can use it in <code>iterate</code> until we get an empty list, which means the Hydra
is DEAD.</p><p>Let&rsquo;s test it on a 3-headed baby Hydra.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>chop-until-dead</span> <span class=p>(</span><span class=nf>new-hydra</span> <span class=mi>3</span><span class=p>))</span>
<span class=c1>;; =&gt; ((3 3 3) (2 2 3 3) (1 2 3 3) (2 3 3) (1 3 3) (3 3)</span>
<span class=c1>;;     (2 2 3) (1 2 3) (2 3) (1 3) (3) (2 2) (1 2) (2) (1))</span>
</code></pre></td></tr></table></div></div><p>How many chops are needed in order to kill the original 9-headed Hydra?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>count </span><span class=p>(</span><span class=nf>chop-until-dead</span> <span class=p>(</span><span class=nf>new-hydra</span> <span class=mi>9</span><span class=p>)))</span>
<span class=c1>;; =&gt; 986409</span>
</code></pre></td></tr></table></div></div><p>Another interesting question: what is the maximum number of heads Hercules
fought at once?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>apply </span><span class=nv>max</span>
       <span class=p>(</span><span class=nb>map </span><span class=nv>count</span>
            <span class=p>(</span><span class=nf>chop-until-dead</span> <span class=p>(</span><span class=nf>new-hydra</span> <span class=mi>9</span><span class=p>))))</span>
<span class=c1>;; =&gt; 37</span>
</code></pre></td></tr></table></div></div><p>Ah. Beautiful.</p></div></div><div class=container><nav class="flex container suggested"><a rel=prev href=/post/learning-from-data/ title="Previous post (older)"><span>Previous</span>
Learning From Data - Course Review</a>
<a rel=next href=/post/why-are-continuations-cool/ title="Next post (newer)"><span>Next</span>
Why Are Continuations So Darn Cool?</a></nav></div></main></main><footer class="footer flex"><section class=container><nav class=footer-links><a href=/daniel_martins.asc>PGP</a>
<a href=/index.xml>RSS</a></nav></section><script async src=/js/features.min.c5d8f3350f5a652f526b982306299353824299adb7a3bd261ecffacc47087f66.js></script></footer></body></html>